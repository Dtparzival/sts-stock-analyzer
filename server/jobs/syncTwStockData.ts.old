import cron from 'node-cron';
import { notifyOwner } from '../_core/notification';
import { getDb } from '../db';
import { twStocks, twStockPrices, twDataSyncStatus, twDataSyncErrors } from '../../drizzle/schema';
import { eq } from 'drizzle-orm';
import { fetchTwseStockList, fetchTwseHistoricalPrices } from '../integrations/twse';
import { fetchTpexStockList, fetchTpexHistoricalPrices } from '../integrations/tpex';
import { transformTwseStock, transformTpexStock, transformHistoricalPrice, transformFundamentals, transformFinancialStatement, transformDividend, calculateMA, calculateRSI } from '../integrations/dataTransformer';
import { fetchFundamentals, fetchFinancialStatement, fetchDividend } from '../integrations/finmind';
import { twStockIndicators, twStockFundamentals, twStockFinancials, twStockDividends } from '../../drizzle/schema';

/**
 * 指數退避重試機制
 * @param fn 要執行的函數
 * @param maxRetries 最大重試次數
 * @param symbol 股票代號（用於錯誤記錄）
 */
async function retryWithExponentialBackoff<T>(
  fn: () => Promise<T>,
  maxRetries: number = 3,
  symbol?: string
): Promise<T> {
  let lastError: Error | null = null;
  
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error as Error;
      const waitTime = Math.pow(2, attempt) * 1000; // 1s, 2s, 4s
      
      console.warn(`[Sync] Retry attempt ${attempt + 1}/${maxRetries} for ${symbol || 'unknown'}, waiting ${waitTime}ms...`);
      
      if (attempt < maxRetries - 1) {
        await new Promise(resolve => setTimeout(resolve, waitTime));
      }
    }
  }
  
  // 記錄錯誤到資料庫
  if (symbol && lastError) {
    await recordSyncError(symbol, 'retry_failed', lastError, maxRetries);
  }
  
  throw lastError;
}

/**
 * 記錄同步錯誤到資料庫
 */
async function recordSyncError(
  symbol: string,
  errorType: string,
  error: Error,
  retryCount: number
): Promise<void> {
  try {
    const db = await getDb();
    if (!db) return;
    
    await db.insert(twDataSyncErrors).values({
      symbol,
      errorType,
      errorMessage: error.message,
      errorStack: error.stack || '',
      retryCount,
      syncedAt: new Date(),
    });
  } catch (err) {
    console.error('[Sync] Failed to record sync error:', err);
  }
}

/**
 * 格式化日期為 YYYY-MM-DD
 */
function formatDate(date: Date): string {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
}

/**
 * 同步歷史價格資料（增量更新）
 */
async function syncHistoricalPrices(): Promise<void> {
  const db = await getDb();
  if (!db) {
    console.error('[Sync] Database not available');
    return;
  }
  
  console.log('[Sync] Starting historical prices sync...');
  
  try {
    // 1. 取得最後同步時間
    const syncStatus = await db.select()
      .from(twDataSyncStatus)
      .where(eq(twDataSyncStatus.dataType, 'prices'))
      .limit(1);
    
    const lastSyncDate = syncStatus.length > 0 
      ? syncStatus[0].lastSyncAt 
      : new Date('2020-01-01');
    
    console.log(`[Sync] Last sync date: ${formatDate(lastSyncDate)}`);
    
    // 2. 取得所有活躍股票
    const stocks = await db.select()
      .from(twStocks)
      .where(eq(twStocks.isActive, true));
    
    console.log(`[Sync] Found ${stocks.length} active stocks`);
    
    let successCount = 0;
    let failedStocks: string[] = [];
    
    // 3. 逐一更新每支股票的歷史價格
    for (const stock of stocks) {
      try {
        console.log(`[Sync] Syncing prices for ${stock.symbol} (${stock.name})...`);
        
        const rawData = await retryWithExponentialBackoff(async () => {
          if (stock.market === '上市') {
            return await fetchTwseHistoricalPrices(stock.symbol, formatDate(lastSyncDate));
          } else {
            return await fetchTpexHistoricalPrices(
              stock.symbol,
              formatDate(lastSyncDate),
              formatDate(new Date())
            );
          }
        }, 3, stock.symbol);
        
        if (!rawData || rawData.length === 0) {
          console.log(`[Sync] No new data for ${stock.symbol}`);
          continue;
        }
        
        const transformedData = rawData.map((item: any) => ({
          symbol: stock.symbol,
          ...transformHistoricalPrice(item, stock.market === '上市' ? 'TWSE' : 'TPEx')
        }));
        
        // 4. 批次寫入資料庫（使用 onDuplicateKeyUpdate 避免重複）
        for (const priceData of transformedData) {
          await db.insert(twStockPrices).values(priceData).onDuplicateKeyUpdate({
            set: {
              open: priceData.open,
              high: priceData.high,
              low: priceData.low,
              close: priceData.close,
              volume: priceData.volume,
              amount: priceData.amount,
              change: priceData.change,
              changePercent: priceData.changePercent,
            }
          });
        }
        
        successCount++;
        console.log(`[Sync] Successfully synced ${transformedData.length} records for ${stock.symbol}`);
        
      } catch (error) {
        console.error(`[Sync] Failed to sync prices for ${stock.symbol}:`, error);
        failedStocks.push(stock.symbol);
      }
    }
    
    // 5. 更新同步狀態
    await db.insert(twDataSyncStatus).values({
      dataType: 'prices',
      source: 'TWSE+TPEx',
      lastSyncAt: new Date(),
      status: failedStocks.length === 0 ? 'success' : 'partial',
      recordCount: successCount,
      errorMessage: failedStocks.length > 0 ? `Failed stocks: ${failedStocks.join(', ')}` : null,
    }).onDuplicateKeyUpdate({
      set: {
        lastSyncAt: new Date(),
        status: failedStocks.length === 0 ? 'success' : 'partial',
        recordCount: successCount,
        errorMessage: failedStocks.length > 0 ? `Failed stocks: ${failedStocks.join(', ')}` : null,
      }
    });
    
    console.log(`[Sync] Historical prices sync completed. Success: ${successCount}, Failed: ${failedStocks.length}`);
    
    // 6. 如果有失敗的股票，發送通知
    if (failedStocks.length > 0) {
      await notifyOwner({
        title: '台股歷史價格同步部分失敗',
        content: `成功: ${successCount} 支股票\n失敗: ${failedStocks.length} 支股票\n失敗股票代號: ${failedStocks.join(', ')}`
      });
    }
    
  } catch (error) {
    console.error('[Sync] Historical prices sync failed:', error);
    
    // 發送錯誤通知
    await notifyOwner({
      title: '台股歷史價格同步失敗',
      content: `錯誤訊息: ${(error as Error).message}`
    });
    
    throw error;
  }
}

/**
 * 每日收盤後更新歷史價格（交易日 14:30）
 */
export function scheduleHistoricalPricesSync(): void {
  cron.schedule('30 14 * * 1-5', async () => {
    console.log('[Sync] Starting scheduled historical prices sync...');
    try {
      await syncHistoricalPrices();
    } catch (error) {
      console.error('[Sync] Scheduled historical prices sync failed:', error);
    }
  }, {
    timezone: 'Asia/Taipei'
  });
  
  console.log('[Sync] Scheduled historical prices sync (Mon-Fri 14:30 Asia/Taipei)');
}

/**
 * 同步基本面資料（使用 FinMind API）
 */
async function syncFundamentals(): Promise<void> {
  const db = await getDb();
  if (!db) {
    console.error('[Sync] Database not available');
    return;
  }
  
  console.log('[Sync] Starting fundamentals sync...');
  
  try {
    // 1. 取得最後同步時間
    const syncStatus = await db.select()
      .from(twDataSyncStatus)
      .where(eq(twDataSyncStatus.dataType, 'fundamentals'))
      .limit(1);
    
    const lastSyncDate = syncStatus.length > 0 
      ? syncStatus[0].lastSyncAt 
      : new Date('2020-01-01');
    
    console.log(`[Sync] Last sync date: ${formatDate(lastSyncDate)}`);
    
    // 2. 取得所有活躍股票
    const stocks = await db.select()
      .from(twStocks)
      .where(eq(twStocks.isActive, true));
    
    console.log(`[Sync] Found ${stocks.length} active stocks`);
    
    let successCount = 0;
    let failedStocks: string[] = [];
    
    // 3. 逐一更新每支股票的基本面資料
    for (const stock of stocks) {
      try {
        console.log(`[Sync] Syncing fundamentals for ${stock.symbol} (${stock.name})...`);
        
        const rawData = await retryWithExponentialBackoff(async () => {
          return await fetchFundamentals(stock.symbol, formatDate(lastSyncDate));
        }, 3, stock.symbol);
        
        if (!rawData || rawData.length === 0) {
          console.log(`[Sync] No new data for ${stock.symbol}`);
          continue;
        }
        
        const transformedData = rawData.map((item: any) => 
          transformFundamentals(item, stock.symbol)
        );
        
        // 4. 批次寫入資料庫
        for (const fundamentalData of transformedData) {
          await db.insert(twStockFundamentals).values(fundamentalData).onDuplicateKeyUpdate({
            set: {
              eps: fundamentalData.eps,
              pe: fundamentalData.pe,
              pb: fundamentalData.pb,
              roe: fundamentalData.roe,
              dividend: fundamentalData.dividend,
              yieldRate: fundamentalData.yieldRate,
              revenue: fundamentalData.revenue,
              netIncome: fundamentalData.netIncome,
            }
          });
        }
        
        successCount++;
        console.log(`[Sync] Successfully synced ${transformedData.length} records for ${stock.symbol}`);
        
      } catch (error) {
        console.error(`[Sync] Failed to sync fundamentals for ${stock.symbol}:`, error);
        failedStocks.push(stock.symbol);
      }
    }
    
    // 5. 更新同步狀態
    await db.insert(twDataSyncStatus).values({
      dataType: 'fundamentals',
      source: 'FinMind',
      lastSyncAt: new Date(),
      status: failedStocks.length === 0 ? 'success' : 'partial',
      recordCount: successCount,
      errorMessage: failedStocks.length > 0 ? `Failed stocks: ${failedStocks.join(', ')}` : null,
    }).onDuplicateKeyUpdate({
      set: {
        lastSyncAt: new Date(),
        status: failedStocks.length === 0 ? 'success' : 'partial',
        recordCount: successCount,
        errorMessage: failedStocks.length > 0 ? `Failed stocks: ${failedStocks.join(', ')}` : null,
      }
    });
    
    console.log(`[Sync] Fundamentals sync completed. Success: ${successCount}, Failed: ${failedStocks.length}`);
    
    // 6. 如果有失敗的股票，發送通知
    if (failedStocks.length > 0) {
      await notifyOwner({
        title: '台股基本面資料同步部分失敗',
        content: `成功: ${successCount} 支股票\n失敗: ${failedStocks.length} 支股票\n失敗股票代號: ${failedStocks.join(', ')}`
      });
    }
    
  } catch (error) {
    console.error('[Sync] Fundamentals sync failed:', error);
    
    await notifyOwner({
      title: '台股基本面資料同步失敗',
      content: `錯誤訊息: ${(error as Error).message}`
    });
    
    throw error;
  }
}

/**
 * 每週日凌晨更新基本面資料
 */
export function scheduleFundamentalsSync(): void {
  cron.schedule('0 2 * * 0', async () => {
    console.log('[Sync] Starting scheduled fundamentals sync...');
    try {
      await syncFundamentals();
    } catch (error) {
      console.error('[Sync] Scheduled fundamentals sync failed:', error);
    }
  }, {
    timezone: 'Asia/Taipei'
  });
  
  console.log('[Sync] Scheduled fundamentals sync (Sunday 02:00 Asia/Taipei)');
}

/**
 * 同步技術指標（基於歷史價格計算）
 */
async function syncIndicators(): Promise<void> {
  const db = await getDb();
  if (!db) {
    console.error('[Sync] Database not available');
    return;
  }
  
  console.log('[Sync] Starting indicators sync...');
  
  try {
    // 1. 取得所有活躍股票
    const stocks = await db.select()
      .from(twStocks)
      .where(eq(twStocks.isActive, true));
    
    console.log(`[Sync] Found ${stocks.length} active stocks`);
    
    let successCount = 0;
    let failedStocks: string[] = [];
    
    // 2. 逐一計算每支股票的技術指標
    for (const stock of stocks) {
      try {
        console.log(`[Sync] Calculating indicators for ${stock.symbol} (${stock.name})...`);
        
        // 取得最近 120 天的歷史價格（計算 MA60 需要至少 60 筆資料）
        const startDate = new Date();
        startDate.setDate(startDate.getDate() - 120);
        
        const prices = await db.select()
          .from(twStockPrices)
          .where(eq(twStockPrices.symbol, stock.symbol));
        
        if (prices.length < 20) {
          console.log(`[Sync] Not enough price data for ${stock.symbol} (${prices.length} records)`);
          continue;
        }
        
        // 計算技術指標
        // 按日期排序價格資料
        const sortedPrices = prices.sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());
        const closePrices = sortedPrices.map(p => p.close);
        
        // 計算最新的技術指標
        const latestDate = sortedPrices[sortedPrices.length - 1].date;
        const ma5 = calculateMA(closePrices, 5);
        const ma10 = calculateMA(closePrices, 10);
        const ma20 = calculateMA(closePrices, 20);
        const ma60 = calculateMA(closePrices, 60);
        const rsi14 = calculateRSI(closePrices, 14);
        
        // 3. 寫入資料庫
        await db.insert(twStockIndicators).values({
          symbol: stock.symbol,
          date: latestDate,
          ma5,
          ma10,
          ma20,
          ma60,
          rsi14,
          macd: null,
          macdSignal: null,
          macdHistogram: null,
          kValue: null,
          dValue: null,
        }).onDuplicateKeyUpdate({
          set: {
            ma5,
            ma10,
            ma20,
            ma60,
            rsi14,
          }
        });
        
        
        successCount++;
        console.log(`[Sync] Successfully calculated indicators for ${stock.symbol}`);
        
      } catch (error) {
        console.error(`[Sync] Failed to calculate indicators for ${stock.symbol}:`, error);
        failedStocks.push(stock.symbol);
      }
    }
    
    // 4. 更新同步狀態
    await db.insert(twDataSyncStatus).values({
      dataType: 'indicators',
      source: 'Calculated',
      lastSyncAt: new Date(),
      status: failedStocks.length === 0 ? 'success' : 'partial',
      recordCount: successCount,
      errorMessage: failedStocks.length > 0 ? `Failed stocks: ${failedStocks.join(', ')}` : null,
    }).onDuplicateKeyUpdate({
      set: {
        lastSyncAt: new Date(),
        status: failedStocks.length === 0 ? 'success' : 'partial',
        recordCount: successCount,
        errorMessage: failedStocks.length > 0 ? `Failed stocks: ${failedStocks.join(', ')}` : null,
      }
    });
    
    console.log(`[Sync] Indicators sync completed. Success: ${successCount}, Failed: ${failedStocks.length}`);
    
    // 5. 如果有失敗的股票，發送通知
    if (failedStocks.length > 0) {
      await notifyOwner({
        title: '台股技術指標計算部分失敗',
        content: `成功: ${successCount} 支股票\n失敗: ${failedStocks.length} 支股票\n失敗股票代號: ${failedStocks.join(', ')}`
      });
    }
    
  } catch (error) {
    console.error('[Sync] Indicators sync failed:', error);
    
    await notifyOwner({
      title: '台股技術指標計算失敗',
      content: `錯誤訊息: ${(error as Error).message}`
    });
    
    throw error;
  }
}

/**
 * 同步財務報表（使用 FinMind API）
 */
async function syncFinancials(): Promise<void> {
  const db = await getDb();
  if (!db) {
    console.error('[Sync] Database not available');
    return;
  }
  
  console.log('[Sync] Starting financials sync...');
  
  try {
    const syncStatus = await db.select()
      .from(twDataSyncStatus)
      .where(eq(twDataSyncStatus.dataType, 'financials'))
      .limit(1);
    
    const lastSyncDate = syncStatus.length > 0 
      ? syncStatus[0].lastSyncAt 
      : new Date('2020-01-01');
    
    const stocks = await db.select()
      .from(twStocks)
      .where(eq(twStocks.isActive, true));
    
    let successCount = 0;
    let failedStocks: string[] = [];
    
    for (const stock of stocks) {
      try {
        console.log(`[Sync] Syncing financials for ${stock.symbol} (${stock.name})...`);
        
        const rawData = await retryWithExponentialBackoff(async () => {
          return await fetchFinancialStatement(stock.symbol, formatDate(lastSyncDate));
        }, 3, stock.symbol);
        
        if (!rawData || rawData.length === 0) {
          console.log(`[Sync] No new data for ${stock.symbol}`);
          continue;
        }
        
        const transformedData = rawData.map((item: any) => 
          transformFinancialStatement(item, stock.symbol)
        );
        
        for (const financialData of transformedData) {
          await db.insert(twStockFinancials).values(financialData).onDuplicateKeyUpdate({
            set: {
              totalAssets: financialData.totalAssets,
              totalLiabilities: financialData.totalLiabilities,
              totalEquity: financialData.totalEquity,
              currentAssets: financialData.currentAssets,
              currentLiabilities: financialData.currentLiabilities,
              revenue: financialData.revenue,
              operatingIncome: financialData.operatingIncome,
              netIncome: financialData.netIncome,
              grossProfit: financialData.grossProfit,
              operatingExpenses: financialData.operatingExpenses,
              operatingCashFlow: financialData.operatingCashFlow,
              investingCashFlow: financialData.investingCashFlow,
              financingCashFlow: financialData.financingCashFlow,
              freeCashFlow: financialData.freeCashFlow,
            }
          });
        }
        
        successCount++;
        console.log(`[Sync] Successfully synced ${transformedData.length} records for ${stock.symbol}`);
        
      } catch (error) {
        console.error(`[Sync] Failed to sync financials for ${stock.symbol}:`, error);
        failedStocks.push(stock.symbol);
      }
    }
    
    await db.insert(twDataSyncStatus).values({
      dataType: 'financials',
      source: 'FinMind',
      lastSyncAt: new Date(),
      status: failedStocks.length === 0 ? 'success' : 'partial',
      recordCount: successCount,
      errorMessage: failedStocks.length > 0 ? `Failed stocks: ${failedStocks.join(', ')}` : null,
    }).onDuplicateKeyUpdate({
      set: {
        lastSyncAt: new Date(),
        status: failedStocks.length === 0 ? 'success' : 'partial',
        recordCount: successCount,
        errorMessage: failedStocks.length > 0 ? `Failed stocks: ${failedStocks.join(', ')}` : null,
      }
    });
    
    console.log(`[Sync] Financials sync completed. Success: ${successCount}, Failed: ${failedStocks.length}`);
    
    if (failedStocks.length > 0) {
      await notifyOwner({
        title: '台股財務報表同步部分失敗',
        content: `成功: ${successCount} 支股票\n失敗: ${failedStocks.length} 支股票\n失敗股票代號: ${failedStocks.join(', ')}`
      });
    }
    
  } catch (error) {
    console.error('[Sync] Financials sync failed:', error);
    await notifyOwner({
      title: '台股財務報表同步失敗',
      content: `錯誤訊息: ${(error as Error).message}`
    });
    throw error;
  }
}

/**
 * 同步股利資訊（使用 FinMind API）
 */
async function syncDividends(): Promise<void> {
  const db = await getDb();
  if (!db) {
    console.error('[Sync] Database not available');
    return;
  }
  
  console.log('[Sync] Starting dividends sync...');
  
  try {
    const syncStatus = await db.select()
      .from(twDataSyncStatus)
      .where(eq(twDataSyncStatus.dataType, 'dividends'))
      .limit(1);
    
    const lastSyncDate = syncStatus.length > 0 
      ? syncStatus[0].lastSyncAt 
      : new Date('2020-01-01');
    
    const stocks = await db.select()
      .from(twStocks)
      .where(eq(twStocks.isActive, true));
    
    let successCount = 0;
    let failedStocks: string[] = [];
    
    for (const stock of stocks) {
      try {
        console.log(`[Sync] Syncing dividends for ${stock.symbol} (${stock.name})...`);
        
        const rawData = await retryWithExponentialBackoff(async () => {
          return await fetchDividend(stock.symbol, formatDate(lastSyncDate));
        }, 3, stock.symbol);
        
        if (!rawData || rawData.length === 0) {
          console.log(`[Sync] No new data for ${stock.symbol}`);
          continue;
        }
        
        const transformedData = rawData.map((item: any) => 
          transformDividend(item, stock.symbol)
        );
        
        for (const dividendData of transformedData) {
          await db.insert(twStockDividends).values(dividendData).onDuplicateKeyUpdate({
            set: {
              cashDividend: dividendData.cashDividend,
              stockDividend: dividendData.stockDividend,
              totalDividend: dividendData.totalDividend,
              exDividendDate: dividendData.exDividendDate,
              paymentDate: dividendData.paymentDate,
              yieldRate: dividendData.yieldRate,
              payoutRatio: dividendData.payoutRatio,
            }
          });
        }
        
        successCount++;
        console.log(`[Sync] Successfully synced ${transformedData.length} records for ${stock.symbol}`);
        
      } catch (error) {
        console.error(`[Sync] Failed to sync dividends for ${stock.symbol}:`, error);
        failedStocks.push(stock.symbol);
      }
    }
    
    await db.insert(twDataSyncStatus).values({
      dataType: 'dividends',
      source: 'FinMind',
      lastSyncAt: new Date(),
      status: failedStocks.length === 0 ? 'success' : 'partial',
      recordCount: successCount,
      errorMessage: failedStocks.length > 0 ? `Failed stocks: ${failedStocks.join(', ')}` : null,
    }).onDuplicateKeyUpdate({
      set: {
        lastSyncAt: new Date(),
        status: failedStocks.length === 0 ? 'success' : 'partial',
        recordCount: successCount,
        errorMessage: failedStocks.length > 0 ? `Failed stocks: ${failedStocks.join(', ')}` : null,
      }
    });
    
    console.log(`[Sync] Dividends sync completed. Success: ${successCount}, Failed: ${failedStocks.length}`);
    
    if (failedStocks.length > 0) {
      await notifyOwner({
        title: '台股股利資訊同步部分失敗',
        content: `成功: ${successCount} 支股票\n失敗: ${failedStocks.length} 支股票\n失敗股票代號: ${failedStocks.join(', ')}`
      });
    }
    
  } catch (error) {
    console.error('[Sync] Dividends sync failed:', error);
    await notifyOwner({
      title: '台股股利資訊同步失敗',
      content: `錯誤訊息: ${(error as Error).message}`
    });
    throw error;
  }
}

/**
 * 每日收盤後更新技術指標（交易日 15:00）
 */
export function scheduleIndicatorsSync(): void {
  cron.schedule('0 15 * * 1-5', async () => {
    console.log('[Sync] Starting scheduled indicators sync...');
    try {
      await syncIndicators();
    } catch (error) {
      console.error('[Sync] Scheduled indicators sync failed:', error);
    }
  }, {
    timezone: 'Asia/Taipei'
  });
  
  console.log('[Sync] Scheduled indicators sync (Mon-Fri 15:00 Asia/Taipei)');
}

/**
 * 每週日凌晨更新財務報表（週日 03:00）
 */
export function scheduleFinancialsSync(): void {
  cron.schedule('0 3 * * 0', async () => {
    console.log('[Sync] Starting scheduled financials sync...');
    try {
      await syncFinancials();
    } catch (error) {
      console.error('[Sync] Scheduled financials sync failed:', error);
    }
  }, {
    timezone: 'Asia/Taipei'
  });
  
  console.log('[Sync] Scheduled financials sync (Sunday 03:00 Asia/Taipei)');
}

/**
 * 每週日凌晨更新股利資訊（週日 04:00）
 */
export function scheduleDividendsSync(): void {
  cron.schedule('0 4 * * 0', async () => {
    console.log('[Sync] Starting scheduled dividends sync...');
    try {
      await syncDividends();
    } catch (error) {
      console.error('[Sync] Scheduled dividends sync failed:', error);
    }
  }, {
    timezone: 'Asia/Taipei'
  });
  
  console.log('[Sync] Scheduled dividends sync (Sunday 04:00 Asia/Taipei)');
}

/**
 * 啟動所有排程任務
 */
export function startAllSchedules(): void {
  scheduleHistoricalPricesSync();
  scheduleFundamentalsSync();
  scheduleIndicatorsSync();
  scheduleFinancialsSync();
  scheduleDividendsSync();
  console.log('[Sync] All schedules started');
}

/**
 * 手動觸發歷史價格同步（用於測試或手動補資料）
 */
export async function manualSyncHistoricalPrices(): Promise<void> {
  console.log('[Sync] Manual historical prices sync triggered');
  await syncHistoricalPrices();
}

/**
 * 手動觸發基本面資料同步
 */
export async function manualSyncFundamentals(): Promise<void> {
  console.log('[Sync] Manual fundamentals sync triggered');
  await syncFundamentals();
}

/**
 * 手動觸發技術指標計算
 */
export async function manualSyncIndicators(): Promise<void> {
  console.log('[Sync] Manual indicators sync triggered');
  await syncIndicators();
}

/**
 * 手動觸發財務報表同步
 */
export async function manualSyncFinancials(): Promise<void> {
  console.log('[Sync] Manual financials sync triggered');
  await syncFinancials();
}

/**
 * 手動觸發股利資訊同步
 */
export async function manualSyncDividends(): Promise<void> {
  console.log('[Sync] Manual dividends sync triggered');
  await syncDividends();
}

/**
 * 手動觸發完整資料同步（所有資料類型）
 */
export async function manualSyncAll(): Promise<void> {
  console.log('[Sync] Manual full sync triggered');
  
  try {
    console.log('[Sync] Step 1/5: Syncing historical prices...');
    await syncHistoricalPrices();
    
    console.log('[Sync] Step 2/5: Syncing fundamentals...');
    await syncFundamentals();
    
    console.log('[Sync] Step 3/5: Calculating indicators...');
    await syncIndicators();
    
    console.log('[Sync] Step 4/5: Syncing financials...');
    await syncFinancials();
    
    console.log('[Sync] Step 5/5: Syncing dividends...');
    await syncDividends();
    
    console.log('[Sync] Full sync completed successfully!');
    
    await notifyOwner({
      title: '台股完整資料同步完成',
      content: '所有資料類型（歷史價格、基本面、技術指標、財務報表、股利資訊）已成功同步'
    });
  } catch (error) {
    console.error('[Sync] Full sync failed:', error);
    
    await notifyOwner({
      title: '台股完整資料同步失敗',
      content: `錯誤訊息: ${(error as Error).message}`
    });
    
    throw error;
  }
}
